#!/usr/bin/env python

"""
A test execution wrapper for Robot Framework.
"""

from __future__ import print_function
import os
import sys
import platform
import shutil
import argparse
import subprocess
import robot


def test_and_install_package():
    """
    Test importing 3rd party modules required by BigRbot. If import fails,
    then attempt to install the package.

    Important: This step is performed before autobot modules can be loaded.
    So we can't depend on aubobot.helpers and similar facilities.
    """
    def _test_and_install(package, module):
        try:
            return __import__(module)
        except ImportError:
            print("Failed to import module '%s'. Will try to install it."
                  % module)
            if os.stat(os.__file__).st_uid == os.getuid():
                # Current user has permission to install module...
                cmd = "pip install %s" % package
            else:
                cmd = "sudo pip install %s" % package
            print("Executing '%s'" % cmd)
            subprocess.call(cmd, shell=True)

    packages = {
                'pylint': 'pylint',
                'httplib2': 'httplib2',
                'pyyaml': 'yaml',
                'pytz': 'pytz',
                'ipcalc': 'ipcalc',
                'netaddr': 'netaddr',
                'pycrypto': 'Crypto',
                'paramiko': 'paramiko',
                'scp': 'scp',
                'pexpect': 'pexpect',
                'robotframework': 'robot',
                # 'robotframework-ride': 'robotide',
                # 'pep8': '???',  # not possible to test import pep8 package
                }

    for k, v in packages.iteritems():
        _test_and_install(k, v)


def set_environment():
    """
    Look for user-defined environments BIGROBOT_PATH and BIGTEST_PATH. If they
    don't exist then assume some defaults. Add them to Python path.
    """

    system = platform.system()
    if system == 'Darwin':
        p = '%s/Documents/workspace' % os.path.expanduser('~')
    elif system == 'Linux':
        p = '%s/workspace' % os.path.expanduser('~')
    else:
        sys.stderr.write("BigRobot is only supported on OSX and Linux.")
        sys.exit(1)

    if 'BIGROBOT_PATH' not in os.environ:
        os.environ['BIGROBOT_PATH'] = ''.join((p, '/bigrobot'))

    if 'BIGTEST_PATH' not in os.environ:
        os.environ['BIGTEST_PATH'] = ''.join((p, '/bigtest'))

    # Add paths to PYTHONPATH
    sys.path.insert(0, os.environ['BIGROBOT_PATH'])
    sys.path.insert(1, os.environ['BIGTEST_PATH'])
    exscript_path = ''.join((os.environ['BIGROBOT_PATH'],
                             '/vendors/exscript/src'))
    sys.path.insert(2, exscript_path)

    # (Re-)export PYTHONPATH environment
    os.environ['PYTHONPATH'] = os.pathsep.join(sys.path)


def test_autobot_import():
    """
    Test importing the Autobot package. This must work else we fail hard.
    """
    try:
        import autobot.version
        autobot.version.get_version()  # just to silence the "unused" warning
    except ImportError:
        sys.stderr.write(
            "Error: Cannot find Autobot package. Please check PYTHONPATH,"
            " BIGROBOT_PATH, and BIGTEST_PATH environment variables.\n")
        sys.stderr.write("  BIGROBOT_PATH=%s\n" % os.environ['BIGROBOT_PATH'])
        sys.stderr.write("  BIGTEST_PATH=%s\n" % os.environ['BIGTEST_PATH'])
        sys.stderr.write("  PYTHONPATH=%s" % os.environ['PYTHONPATH'])
        sys.exit(1)


test_and_install_package()
set_environment()
test_autobot_import()

import autobot.helpers as helpers

#
# Gobot initialization
#

os.environ['IS_GOBOT'] = 'True'

helpers.bigrobot_log_path(default='.')
if helpers.bigrobot_suite():
    helpers.bigrobot_log_path_exec_instance_relative(
                default="%s_%s"
                % (helpers.bigrobot_suite(), helpers.ts_local()))
else:
    helpers.bigrobot_log_path_exec_instance_relative(
                default="<bigrobot_suite>")
helpers.bigrobot_log_path_exec_instance(
            default="%s/%s"
            % (helpers.bigrobot_log_path(),
               helpers.bigrobot_log_path_exec_instance_relative()))

if helpers.bigrobot_suite():
    _topo_p = helpers.bigrobot_suite() + ".physical.topo"
    _topo_v = helpers.bigrobot_suite() + ".virtual.topo"
    _topo_u = helpers.bigrobot_suite() + ".topo"  # p or v unspecified

    if helpers.file_exists(_topo_p):
        topo_file = _topo_p
    elif helpers.file_exists(_topo_v):
        topo_file = _topo_v
    else:
        topo_file = _topo_u

    helpers.bigrobot_topology(default=topo_file)

helpers.bigrobot_params(default='None')
helpers.bigrobot_continuous_integration()
helpers.bigrobot_exec_hint_format()
helpers.bigrobot_debug(default=1)

# !!! FIXME: 2014-04-10 Exscript's Protocol.py sys.stderr is closed for some
#     reason, which causes SSH2._dbg() to fail. Still not able to figure out
#     what is causing this (it used to work fine). The workaround is to write
#     the Exscript debug log to a file instead. We achieve this by setting
#     an environment variable BIGROBOT_EXSCRIPT_DEBUG_LOG_PATH which
#      Exscript's Protocol will pick up.
#
#     Note: This env should only be set after bigrobot_log_path_exec_instance()
#           is set.
helpers.bigrobot_excript_debug_log_path(
      default=helpers.bigrobot_log_path_exec_instance())

helpers.bigrobot_listener_log(
      default=''.join((helpers.bigrobot_log_path_exec_instance(),
                       '/bigrobot_listener.log')))
helpers.bigrobot_devcmd_log(
      default=''.join((helpers.bigrobot_log_path_exec_instance(),
                       '/dev_commands.log')))

helpers.bigrobot_path()
helpers.bigtest_path()
helpers.python_path()
helpers.bigrobot_test_setup()  # (default=True)
helpers.bigrobot_test_postmortem()  # (default=True)
helpers.bigrobot_test_pause_on_fail()  # (default=False)


def get_command_dict():
    """
    Extract command names from functions which end with '_command' and place
    them in a dictionary. E.g.,
        test_command()
    """
    commands = {}
    for x in globals():
        if not x.endswith("_command"):
            continue
        name, func = x[:-8], globals()[x]
        commands[name] = func
    return commands


def usage():
    """
    Usage information for 'gobot'.
    """
    version_hidden_command()
    print("\nUsage: gobot [command] [options]\n")

    # Print a list of all the test suites in the current directory.
    # Files extension should match the suite extension (e.g., 'txt').

    file_list = []
    for (_, _, filenames) in os.walk('.'):
        file_list.extend(filenames)
        break

    # List of test suites, with file extension removed
    suite_list = [os.path.splitext(f)[0] for f in file_list if f.endswith('txt')]

    print("  Point environment variable BIGROBOT_SUITE to a test suite."
          " Select one below:")
    for _ in sorted(suite_list):
        print("    " + helpers.bigrobot_exec_hint_format() % _)

    if not suite_list:
        print("    export BIGROBOT_SUITE=<testsuite_name>")

    print("")

    # Print the gobot commands
    cmd_list = []
    for cmd, func in sorted(get_command_dict().items()):
        if cmd.endswith("_hidden"):
            # Don't display hidden commands
            continue
        if func.__doc__:
            cmd_list.append("  %s - %s" % (cmd, func.__doc__))
        else:
            cmd_list.append("  %s" % cmd)

    print("Commands:\n%s" % "\n".join(cmd_list))


def is_topology_defined():
    """
    Check whether topo file is specified (via env BIGROBOT_TOPOLOGY) and
    whether the file exists.
    """
    topo = helpers.bigrobot_topology()
    if topo and os.path.isfile(topo):
        return True
    else:
        # Topology file is not defined or does not exist
        return False


def warn_if_topology_not_defined():
    """
    Create warning log if topology is not defined.
    """
    if not is_topology_defined():
        helpers.warn("Topology file (%s) is not defined.\n"
                     % helpers.bigrobot_topology(), level=None)


def is_suite_defined():
    """
    Check whether test suite file is specified (via env BIGROBOT_SUITE).
    """
    if helpers.bigrobot_suite() is None:
        return False
    else:
        return True


def exit_if_suite_not_defined():
    """
    Exit program if test suite is not defined.
    """
    if not is_suite_defined():
        helpers.error_exit("BIGROBOT_SUITE environment variable required."
                           " See 'gobot help' for more information.")
    f = ''.join((helpers.bigrobot_suite(), '.txt'))
    if not os.path.exists(f):
        helpers.error_exit("Test suite file '%s' does not exist." % f)


def run(cmd, cwd=None, shell=True, quiet=False):
    """
    Execute a command.
    """
    status, msg = helpers.run_cmd(cmd, cwd=cwd, shell=shell, quiet=quiet)
    if msg:
        print(msg)
    return status


def copy_suite(f, p, quiet=False):
    """
    Copy suite-related files to the log directory.
    """
    if not os.path.exists(p):
        os.makedirs(p)

    for ext in ('txt', 'topo'):
        filename = ''.join((f, '.', ext))
        if os.path.exists(filename):
            shutil.copy(filename, p)


def touch_log_files():
    log_files = ['debug.log', 'syslog.txt', 'log.html', 'report.html',
                 'output.xml', 'bigrobot_listener.log', 'dev_commands.log']
    for f in log_files:
        filename = '/'.join((helpers.bigrobot_log_path_exec_instance(), f))
        # print("Touching file %s" % filename)
        helpers.file_touch(filename)


def create_links_to_logs():
    """
    Create links to the log files located in the log directory. These
    links provide a convenient way to access the logs.
    """
    log_path = helpers.bigrobot_log_path()
    log_path_run = helpers.bigrobot_log_path_exec_instance()

    if log_path == log_path_run:
        # Paths are identical, so don't create links
        return

    log_files = ['debug.log', 'syslog.txt', 'log.html', 'report.html',
                 'output.xml', 'bigrobot_listener.log', 'dev_commands.log']

    for f in log_files:
        f2 = '/'.join((log_path, f))

        helpers.file_remove(f)
        helpers.file_remove(f2)

        source_file = '/'.join((log_path_run, f))

        # Create link only if source file exists
        if helpers.file_exists(source_file):
            os.link(source_file, f)
            if not helpers.file_exists(f2):
                # Create additional link, unless f == f2
                os.link(source_file, f2)

#
# Gobot command definitions
#

def version_hidden_command(*args):
    """
    Show the version of BigRobot.
    """
    _ = args  # unused, silent Pylint
    robot_framework_version = robot.version.VERSION
    import Exscript
    exscript_version = Exscript.version.__version__
    print("BigRobot version        %s" % helpers.get_version())
    print("Robot Framework version %s" % robot_framework_version)
    print("Exscript version        %s" % exscript_version)
    pversion = sys.version_info
    print("Python version          %s.%s.%s"
          % (pversion.major, pversion.minor, pversion.micro))


def test_command(*args):
    """
    Run tests in the test suite.
    """
    descr = ("Run a BigRobot test suite. Be sure to point the environment"
             " variable BIGROBOT_SUITE to a test suite (e.g.,"
             " export BIGROBOT_SUITE=mytest).")
    parser = argparse.ArgumentParser(prog='gobot test',
                                     description=descr)

    parser.add_argument('--include', metavar=('tag1', 'tag2'), nargs='*',
                        help='Run test cases by tags')
    parser.add_argument('--exclude',
                        metavar=('tag1', 'tag2'), nargs='*',
                        help='Exclude test cases by tags')
    parser.add_argument('--test',
                        metavar=('name1', 'name2'), nargs='*',
                        help='Run test cases by name (must match entire string)')
    parser.add_argument('--testmatch',
                        metavar=('name1', 'name2'), nargs='*',
                        help='Run test cases by name (match anywhere)')
    parser.add_argument('--randomize', action='store_true', dest='randomize',
                        default=False,
                        help="Run test cases in random orders")
    parser.add_argument('--loglevel', default='trace',
                        help="Log level ('trace', 'debug', 'info')")
    parser.add_argument('--debugfile', default='debug.log',
                        help="Debug file")
    parser.add_argument('--outputdir',
                        default=helpers.bigrobot_log_path_exec_instance(),
                        help="Output directory")

    # Note on --exitonfailure: It will not run subsequent test cases and will
    # simply flag them as failed with the error:
    # "Critical failure occurred and exit-on-failure mode is in use."
    parser.add_argument('--exitonfailure', action='store_true', default=False,
                        help="Stop test execution immediately if any critical test fails")

    args = parser.parse_args(*args)

    include_tags = args.include
    exclude_tags = args.exclude
    if exclude_tags:
        exclude_tags.append('skipped')
    else:
        exclude_tags = ['skipped']

    if args.test:
        print("test_case_names: %s" % args.test)

    # Comparable to command options:
    #   pybot --loglevel=debug \
    #         --debugfile=debug.log \
    #         --exclude=skipped \
    #         --outputdir=./mytest_20140108_052828 \
    #         mytest.txt

    options = {
               'exclude': exclude_tags,
               'loglevel': args.loglevel + ':info',
               'debugfile': args.debugfile,
               'outputdir': args.outputdir,
               'listener': 'autobot.listener.Listener',
               'exitonfailure': args.exitonfailure,
               }
    if include_tags:
        options['include'] = include_tags
    if args.randomize:
        options['randomize'] = 'tests'
    if args.test:
        options['test'] = args.test
    if args.testmatch:
        if 'test' not in options:
            options['test'] = []
        for tc in args.testmatch:
            options['test'].append("*" + tc + "*")

    print("Robot options:\n%s" % helpers.prettify(options))

    exit_if_suite_not_defined()
    warn_if_topology_not_defined()
    copy_suite(helpers.bigrobot_suite(),
               helpers.bigrobot_log_path_exec_instance())

    ext = 'txt'
    test_suite = ''.join((helpers.bigrobot_suite(), '.', ext))

    touch_log_files()
    if helpers.bigrobot_continuous_integration() == 'True':
        # Don't create links to log files under CI environment
        pass
    else:
        create_links_to_logs()

    rc = robot.run(test_suite, **options)
    helpers.log("Robot Framework return code is %s" % rc)
    print("Robot Framework return code is %s" % rc)

    # if helpers.bigrobot_continuous_integration() == 'True':
    #    print("Inside continuous integration environment. Return code"
    #          " set to 0.")
    #    sys.exit(0)
    # else:
    sys.exit(rc)


def env_command(*args):
    """
    Show the environment used by the test suite (useful for debugging purpose).
    """
    _ = args  # unused, silent Pylint
    for env in sorted(helpers.bigrobot_env_list()):
        print("%s=%s" % (env, os.environ[env]))


def gui_command(*args):
    """
    Run the Robot Framework GUI (RIDE).
    """
    _ = args  # unused, silent Pylint
    run('ride.py 2> /dev/null &', shell=True)


def clean_command(*args):
    """
    Remove output files created from Robot runs.
    """
    _ = args  # unused, silent Pylint
    run('rm -f log.html report.html output.xml debug.log syslog.txt'
        ' dev_commands.log bigrobot_listener.log',
        shell=True)


def clean_deep_command(*args):
    """
    Deep cleaning. Run 'clean' command and also remove log directories.
    """
    _ = args  # unused, silent Pylint
    clean_command()

    if is_suite_defined():
        # Remove log directories matching the pattern 'suite_20yymmdd_hhmmss'
        c = 'rm -rfv %s_20[0-9][0-9][0-9][0-9][0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9]' \
             % helpers.bigrobot_suite()
        run(c, shell=True)


def codesize_hidden_command(*args):
    """
    Check the size of BigRobot source code.
    """
    _ = args  # unused, silent Pylint
    cmd = ''.join((helpers.bigrobot_path(), "/bin/chk-code-bloat-bigrobot",
                   " ", helpers.bigrobot_path()))
    run(cmd, shell=True)


def startremotevm_command(*args):
    """
    Setup remote VMs using BigTest (executes 'bt startremotevm').
    """
    _ = args  # unused, silent Pylint
    run('bt startremotevm', cwd=helpers.bigtest_path())


def stopremotevm_command(*args):
    """
    Tear down remote VMs using BigTest (executes 'bt stopremotevm').
    """
    _ = args  # unused, silent Pylint
    run('bt stopremotevm', cwd=helpers.bigtest_path())


def main(args):
    """
    Launch 'gobot'. If no additional argument is specified, print the usage
    guide.
    """
    if not args or args[0] in ['help', '-h', '--help']:
        usage()
        sys.exit(1)

    cmd = args[0]
    cmd_dict = get_command_dict()
    if cmd not in cmd_dict:
        hidden_cmd = cmd + "_hidden"
        if hidden_cmd not in cmd_dict:
            sys.stderr.write("Unknown command: %s\n" % cmd)
            sys.exit(1)
        else:
            cmd = hidden_cmd

    cmd_dict[cmd](args[1:])


if __name__ == '__main__':
    main(sys.argv[1:])
